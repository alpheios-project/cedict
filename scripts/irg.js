import { createRlInterface } from './utility.js'

const irgSourceInfo = {
  path: './src/unihan/',
  fileName: 'Unihan_IRGSources',
  fileExtension: 'txt'
}

let currentCode
let currentEntry
let counter = 0
let metadataStr = ''
const irgData = new Map()
// A list of lines that should be skipped during parsing
const skippableLines = [
  '',
  '#',
  '# EOF'
]
const unicodeFieldName = 'kRSUnicode'

const traditionalCodes = [
  0x0000, // dummy for index 0
  0x4E00, 0x4E28, 0x4E36, 0x4E3F, 0x4E59, 0x4E85, 0x4E8C, 0x4EA0,
  0x4EBA, 0x513F, 0x5165, 0x516B, 0x5182, 0x5196, 0x51AB, 0x51E0,
  0x51F5, 0x5200, 0x529B, 0x52F9, 0x5315, 0x531A, 0x5338, 0x5341,
  0x535C, 0x5369, 0x5382, 0x53B6, 0x53C8, 0x53E3, 0x56D7, 0x571F,
  0x58EB, 0x5902, 0x590A, 0x5915, 0x5927, 0x5973, 0x5B50, 0x5B80,
  0x5BF8, 0x5C0F, 0x5C22, 0x5C38, 0x5C6E, 0x5C71, 0x5DDB, 0x5DE5,
  0x5DF1, 0x5DFE, 0x5E72, 0x5E7A, 0x5E7F, 0x5EF4, 0x5EFE, 0x5F0B,
  0x5F13, 0x5F50, 0x5F61, 0x5F73, 0x5FC3, 0x6208, 0x6236, 0x624B,
  0x652F, 0x6534, 0x6587, 0x6597, 0x65A4, 0x65B9, 0x65E0, 0x65E5,
  0x66F0, 0x6708, 0x6728, 0x6B20, 0x6B62, 0x6B79, 0x6BB3, 0x6BCB,
  0x6BD4, 0x6BDB, 0x6C0F, 0x6C14, 0x6C34, 0x706B, 0x722A, 0x7236,
  0x723B, 0x723F, 0x7247, 0x7259, 0x725B, 0x72AC, 0x7384, 0x7389,
  0x74DC, 0x74E6, 0x7518, 0x751F, 0x7528, 0x7530, 0x758B, 0x7592,
  0x7676, 0x767D, 0x76AE, 0x76BF, 0x76EE, 0x77DB, 0x77E2, 0x77F3,
  0x793A, 0x79B8, 0x79BE, 0x7A74, 0x7ACB, 0x7AF9, 0x7C73, 0x7CF8,
  0x7F36, 0x7F51, 0x7F8A, 0x7FBD, 0x8001, 0x800C, 0x8012, 0x8033,
  0x807F, 0x8089, 0x81E3, 0x81EA, 0x81F3, 0x81FC, 0x820C, 0x821B,
  0x821F, 0x826E, 0x8272, 0x8278, 0x864D, 0x866B, 0x8840, 0x884C,
  0x8863, 0x897E, 0x898B, 0x89D2, 0x8A00, 0x8C37, 0x8C46, 0x8C55,
  0x8C78, 0x8C9D, 0x8D64, 0x8D70, 0x8DB3, 0x8EAB, 0x8ECA, 0x8F9B,
  0x8FB0, 0x8FB5, 0x9091, 0x9149, 0x91C6, 0x91CC, 0x91D1, 0x9577,
  0x9580, 0x961C, 0x96B6, 0x96B9, 0x96E8, 0x9751, 0x975E, 0x9762,
  0x9769, 0x97CB, 0x97ED, 0x97F3, 0x9801, 0x98A8, 0x98DB, 0x98DF,
  0x9996, 0x9999, 0x99AC, 0x9AA8, 0x9AD8, 0x9ADF, 0x9B25, 0x9B2F,
  0x9B32, 0x9B3C, 0x9B5A, 0x9CE5, 0x9E75, 0x9E7F, 0x9EA5, 0x9EBB,
  0x9EC3, 0x9ECD, 0x9ED1, 0x9EF9, 0x9EFD, 0x9F0E, 0x9F13, 0x9F20,
  0x9F3B, 0x9F4A, 0x9F52, 0x9F8D, 0x9F9C, 0x9FA0
]

const simplifiedCodes = [
  0x0000, // dummy for index 0
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x4E2C, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x7E9F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x89C1, 0x89D2, 0x8BA0, 0x003F, 0x003F, 0x003F,
  0x003F, 0x8D1D, 0x003F, 0x003F, 0x003F, 0x003F, 0x8F66, 0x003F,
  0x003F, 0x8FB6, 0x003F, 0x003F, 0x003F, 0x003F, 0x9485, 0x957F,
  0x95E8, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x97E6, 0x003F, 0x003F, 0x9875, 0x98CE, 0x98DE, 0x9963,
  0x003F, 0x003F, 0x9A6C, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
  0x003F, 0x003F, 0x9C7C, 0x9E1F, 0x9E75, 0x003F, 0x9EA6, 0x003F,
  0x9EC4, 0x003F, 0x003F, 0x003F, 0x9EFE, 0x003F, 0x003F, 0x003F,
  0x003F, 0x9F50, 0x9F7F, 0x9F99, 0x9F9F, 0x003F
]

/**
 * This function will be called once for each line from a source file.
 *
 * @param {string} line - A single line from a source file.
 */
const irgLineParser = (line) => {
  counter++
  if (skippableLines.includes(line)) return

  if (/^#/.test(line)) {
    // Assemble metadata into a single string for further parsing
    metadataStr += `${line}\n`
    return
  }

  const parts = line.match(/^(\S*)\s(\S*)\s(.*)$/)
  if (!parts || parts.length !== 4) {
    console.error(`Cannot parse a line ${counter} of IRG source file: ${line}`)
    return
  }

  const code = parts[1]
  if (code !== currentCode) {
    // This is a new entry
    // Store previous entry in the map
    if (currentEntry !== undefined) {
      irgData.set(currentCode, Object.assign({}, currentEntry))
    }
    currentCode = code
    currentEntry = {}
  }
  if (parts[2] === unicodeFieldName) {
    if (parts[3].indexOf(' ') !== -1) {
      // This is a value with multiple radicals, will ignore alternative values for now
      console.error(`Will ignore a second value of a multi-value RSUnicode IRG field for now, ${parts[1]}: ${parts[3]}`)
      const split = parts[3].split(' ')
      parts[3] = split[0]
    }
    const rParts = parts[3].split('.')
    let simplified = false
    if (!rParts || rParts.length !== 2) {
      console.error(`Cannot split a RSUnicode IRG value, ${parts[1]}: ${parts[3]}`)
      return
    }
    let [radicalIndex, additionalStrokes] = rParts
    if (radicalIndex[radicalIndex.length - 1] === '\'') {
      radicalIndex = radicalIndex.substr(0, radicalIndex.length - 1)
      simplified = true
    }
    currentEntry.index = Number.parseInt(radicalIndex, 10)
    currentEntry.additionalStrokes = Number.parseInt(additionalStrokes, 10)
    currentEntry.simplified = simplified

    if ((radicalIndex > 0) && (radicalIndex <= 214)) {
      const code = simplified ? simplifiedCodes[radicalIndex] : traditionalCodes[radicalIndex]
      currentEntry.character = String.fromCharCode(code)
    } else {
      currentEntry.character = '?'
    }
  }
}

/**
 * A function that reads a source file and parses its data.
 *
 * @returns {Promise|Promise} A promise that will be resolved with the map containing data or
 *          rejected if case of an error.
 */
const getIrgData = () => {
  return new Promise((resolve, reject) => {
    const rlInterface = createRlInterface(irgSourceInfo)
    rlInterface.on('line', irgLineParser)
    rlInterface.on('close', () => {
      resolve(irgData)
    })
  })
}

export { getIrgData }
